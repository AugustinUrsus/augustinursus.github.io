<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Leetcode 53</title>
    <url>/2021/12/22/Leetcode-53/</url>
    <content><![CDATA[<h3 id="Leetcode-53-最大子数组和"><a href="#Leetcode-53-最大子数组和" class="headerlink" title="Leetcode 53 最大子数组和"></a>Leetcode 53 最大子数组和</h3><p>给定一个整数组nums返回连续最大和的子数组的和</p>
<p>一个指针即可，用curSum计算每一处的cumulative sum，当curSum小于零时将curSum归零。在遍历时计算maxSum，记录最大和</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        maxSum = nums[<span class="number">0</span>]</span><br><span class="line">        temp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> temp&lt;<span class="number">0</span>:</span><br><span class="line">                temp = <span class="number">0</span></span><br><span class="line">            temp += n</span><br><span class="line">            maxSum = <span class="built_in">max</span>(maxSum, temp)</span><br><span class="line">        <span class="keyword">return</span> maxSum</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/12/18/hello-world/</url>
    <content><![CDATA[<p>Hello, world</p>
]]></content>
  </entry>
  <entry>
    <title>Leetcode-314</title>
    <url>/2021/12/27/Leetcode-314/</url>
    <content><![CDATA[<h3 id="Leetcode-314-二叉树的垂直遍历"><a href="#Leetcode-314-二叉树的垂直遍历" class="headerlink" title="Leetcode 314 二叉树的垂直遍历"></a>Leetcode 314 二叉树的垂直遍历</h3><p>给定一个二叉树的根节点，返回其节点按垂直方向逐列遍历的结果</p>
<p>输入：root = [3,9,20,null,null,15,7]<br>输出：[[9],[3,15],[20],[7]]</p>
<p>DFS，把deque当stack用，先序遍历二叉树，创建dictionary存储层数，最后sort层数输出结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verticalOrder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append((root,<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node, level = queue.popleft()</span><br><span class="line">            res[level].append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append((node.left, level-<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append((node.right, level+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> [res[x] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">sorted</span>(res.keys())]</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
</search>
